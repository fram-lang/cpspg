import List
import open Parser
import Parsing

module Feeder
    pub let withFeeder {Tok}
		   (xs : List Tok)
		   (eof : Tok)
		   (f : {E} -> Parsing.Lex E Tok -> [E] _) =
	handle lex = Parsing.Lex
	    { token = effect () / r =>
		fn ys =>
		    match ys with
		    | [] => r eof ys
		    | y :: ys => r y ys
		    end
	    , curPos = effect () / r => fn ys => r Parsing.dummyPos ys
	    , startPos = effect () / r => fn ys => r Parsing.dummyPos ys }
	    return x => fn _ => x
	    finally f => f xs
	in f lex
end

let bye s = (printStrLn s; exit 1)

let getTree result = 
  match result with
  | Left s => bye s
  | Right t => t
  end

let execTest xs = Feeder.withFeeder xs EOF (fn lex => main {~lex = lex} ())

let test = [LPAREN, LPAREN, ATOM "x", DOT, ATOM "y", RPAREN, DOT, LPAREN, RPAREN, RPAREN]
# '((x . y))

pub let t = getTree (execTest test)

pub let examine s = 
  match s with
  | Nil => "Nil"
  | Atom s => "Atom " + s
  | Cons _ _ => "Cons"
  end

pub let left s = 
  match s with
  | Cons l _ => l
  | _ => bye "no left"
  end

pub let right s = 
  match s with
  | Cons _ r => r
  | _ => bye "no right"
  end

